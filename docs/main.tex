\documentclass[a4paper]{article}

\usepackage[hidelinks]{hyperref}
\usepackage{parskip}
\usepackage{amsmath}
\usepackage{amssymb}

\newtheorem{theorem}{Theorem}
\newtheorem{definition}[theorem]{Definition}
\newtheorem{note}[theorem]{Note}
\newtheorem{example}[theorem]{Example}

% Natural numbers
\newcommand{\N}{\mathbb{N}}

% Schema elements
\newcommand{\ptype}{\tau}
\newcommand{\ptypes}{\mathcal{T}}
\newcommand{\rtype}{\tau^r}
\newcommand{\rtypes}{\mathcal{T}^r}
\newcommand{\btype}{\tau^b}
\newcommand{\btypes}{\mathcal{T}^b}
\newcommand{\gtype}{\tau^g}
\newcommand{\gtypes}{\mathcal{T}^g}

% Semantics (double brackets)
\newcommand{\lsem}{\ensuremath{[\![}}
\newcommand{\rsem}{\ensuremath{]\!]}}
\newcommand{\sem}[1]{\ensuremath{\lsem #1 \rsem}}

% Partial function
\makeatletter
\newcommand{\pto}{}% just for safety
\DeclareRobustCommand{\pto}{\mathrel{\mathpalette\p@to@gets\to}}
\newcommand{\p@to@gets}[2]{%
  \ooalign{\hidewidth$\m@th#1\mapstochar\mkern5mu$\hidewidth\cr$\m@th#1\to$\cr}%
}
\makeatother

\title{Typing Property Graphs}
\author{Nimo Beeren}


\begin{document}

\section{Property Graphs}

We postulate the following countably infinite sets: the set of labels $\mathcal{L}$, the set of property names $\mathcal{N}$ and the set of property values $\mathcal{V}$.

\begin{definition}[Record]
  A \emph{record} is a finite partial function $r : \mathcal{N} \pto \mathcal{V}$ that maps some property names to property values. The set of all records is denoted as $\mathcal{R}$.
\end{definition}

\begin{definition}[Property graph]
  A \emph{property graph} is a tuple $(N, E, \rho, \lambda, \pi)$ where
  \begin{itemize}
    \item $N$ is a finite set of nodes;
    \item $E$ is a finite set of edges such that $N \cap E = \emptyset$;
    \item $\rho : E \to (N \times N) \cup \{\{u, v\} \mid u, v \in N\}$ is a total function mapping edges to ordered or unordered pairs of nodes;
    \item $\lambda : (N \cup E) \to 2^{\mathcal{L}}$ is a total function mapping nodes and edges to a (possibly empty) set of labels;
    \item $\pi : (N \cup E) \to \mathcal{R}$ is a total function mapping nodes and edges to a record.
  \end{itemize}
\end{definition}

We call an edge $e \in E$ \emph{directed} if $\rho(e) \in (N \times N)$ and \emph{undirected} if $\rho(e) \in \{\{u, v\} \mid u, v \in N\}$. We use the umbrella term \emph{elements} to refer to nodes and edges.

\section{Property Graph Schemas}

% TODO: optional properties
% TODO: "any" types, i.e. record with any property, allow edge to any node

We postulate the set of property types $\mathcal{T}$.

\begin{definition}[Property conformance]
  For each property type $\ptype \in \ptypes$ there is a set $\sem{\ptype} \subseteq \mathcal{V}$ that contains all property values that \emph{conform} to the type $\ptype$.
\end{definition}

\begin{definition}[Record type]
  A \emph{record type} is a finite partial function $\rtype : \mathcal{N} \pto \ptypes$ that maps some property names to a property type. We will denote such record types as $\langle a_1 : \rtype_1, \ldots, a_n : \rtype_n \rangle$.
\end{definition}

\begin{definition}[Record conformance]
  We say that a record $r$ \emph{conforms} to a record type $\rtype$, denoted $r \in \sem{\rtype}$, if for each property name $k \in \mathcal{N}$ it holds that (1) $r(k)$ is defined iff $\rtype(k)$ is defined and (2) $r(k) \in \sem{\rtype(k)}$ if $r(k)$ and $\rtype(k)$ are defined.
\end{definition}

Next, we introduce an \emph{element type}\footnote{We typically use the symbol \emph{b} to refer to elements, since \emph{e} is reserved for edges.}, which describes the labels and properties that can be associated with a node or edge.

\begin{definition}[Element type]
  A \emph{element type} is a pair $\btype = (L, \rtype)$ where $L \subseteq \mathcal{L}$ is a finite set of labels and and $\rtype$ a record type. We will denote such element types also simply as $L\rtype$ or $\{ l_1 \ldots l_k \} \langle a_1 : \rtype_1, \ldots, a_n : \rtype_n \rangle$. The set of all element types is denoted as $\btypes$.
\end{definition}

\begin{definition}[Element conformance]
  Given a property graph $(N, E, \rho, \lambda, \pi)$ we say that an element $b \in (N \cup E)$ \emph{conforms} to an element type $\btype = L\rtype$, denoted $b \in \sem{\btype}$, iff (1) $\lambda(b) = L$ and (2) $\pi(b)$ conforms to $\rtype$.
\end{definition}

\begin{definition}[Property graph type]
  A \emph{property graph type} is given by a tuple $\gtype = (N, E, \rho, \beta)$ where 
  \begin{itemize}
    \item $N$ is a finite set of schema nodes;
    \item $E$ is a finite set of schema edges;
    \item $\rho : E \to (N \times N) \cup \{\{u, v\} \mid u, v \in N\}$ is a total function mapping schema edges to ordered or unordered pairs of schema nodes;
    \item $\beta : (N \cup E) \to \btypes$ is a total function mapping schema elements to element types.
    % \item $\ell, u : E \to (\N^\infty \times \N^\infty) \cup \N^\infty$ are total functions mapping edges to cardinality constraints, where $\N^\infty$ is defined as $\{0, 1, 2, \ldots, \infty\}$.
  \end{itemize}
\end{definition}

The similarity between property graph types and property graphs is intentional. This allows us to visualize them in a similar ways, and to use the same mental model to think about them. Indeed, a property graph type can be simulated by a property graph if we allow properties to take property types as values, i.e. $\ptypes \subseteq \mathcal{V}$. Then we let $\lambda$ and $\pi$ take the role of $\beta$, in the sense that $\lambda(b) = L$ and $\pi(b) = \rtype$ if $\beta(b) = L\rtype$ for all elements $b$ of the property graph.

\begin{definition}[Property graph conformance]
  We say that a property graph $G = (N, E, \rho, \lambda, \pi)$ \emph{conforms} to a property graph type $\gtype = (N', E', \rho', \beta)$ if and only if all of the following rules hold.

  \begin{enumerate}
    \item To capture the vocabulary for nodes and edges:
    \begin{enumerate}
      \item $\forall_{n \in N} \exists_{n' \in N'} n \in \sem{\beta(n')}$
      \item $\forall_{e \in E} \exists_{e' \in E'} e \in \sem{\beta(e')}$
    \end{enumerate}
    \item To capture that edges are mandatory:
    \begin{enumerate}
      \item $\forall_{e' \in E'} \forall_{n'_1, n'_2 \in N'} \rho'(e') = (n'_1, n'_2) \implies
      \\\\(\forall_{n_1 \in \sem{\beta(n'_1)}} \exists_{e \in E} e \in \sem{\beta(e')} \wedge \exists_{m_2 \in N} m_2 \in \sem{\beta(n'_2)} \wedge \rho(e) = (n_1, m_2) \wedge
      \\\\ \forall_{n_2 \in \sem{\beta(n'_2)}} \exists_{e \in E} e \in \sem{\beta(e')} \wedge \exists_{m_1 \in N} m_1 \in \sem{\beta(n'_1)} \wedge \rho(e) = (m_1, n_2))$

      \item $\forall_{e' \in E'} \forall_{n'_1, n'_2 \in N'} \rho'(e') = \{n'_1, n'_2\} \implies
      \\\\\forall_{n_1 \in \sem{\beta(n'_1)}} \exists_{e \in E} e \in \sem{\beta(e')} \wedge \exists_{n_2 \in N} n_2 \in \sem{\beta(n'_2)} \wedge \rho(e) = \{n_1, n_2\}$
    \end{enumerate}
  \end{enumerate}
\end{definition}

Under these definitions, all edges in the schema are mandatory. That is, if a schema node $n' \in N'$ has an incident edge $e'$ (i.e. an incoming, outgoing, or undirected edge that $n'$ participates in), then any node $n \in N$ that conforms to $\beta(n')$ must also have one or more incident edges $e$ (in the same direction) that conform to $\beta(e')$. Furthermore, the other endpoint of $e$ must conform to the element type associated with the other endpoint of the schema edge. In the following, we will relax this requirement and allow stricter requirements on cardinality.

% TODO add cardinality back

\end{document}
