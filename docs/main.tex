\documentclass[a4paper]{article}

\usepackage[hidelinks]{hyperref}
\usepackage{parskip}
\usepackage{amsmath}
\usepackage{amssymb}

\newtheorem{theorem}{Theorem}
\newtheorem{definition}[theorem]{Definition}
\newtheorem{note}[theorem]{Note}
\newtheorem{example}[theorem]{Example}

% Natural numbers
\newcommand{\N}{\mathbb{N}}

% Schema elements
\newcommand{\ptype}{\tau}
\newcommand{\ptypes}{\mathcal{T}}
\newcommand{\rtype}{\tau^r}
\newcommand{\rtypes}{\mathcal{T}^r}
\newcommand{\btype}{\tau^b}
\newcommand{\btypes}{\mathcal{T}^b}
\newcommand{\gtype}{\tau^g}
\newcommand{\gtypes}{\mathcal{T}^g}

% Semantics (double brackets)
\newcommand{\lsem}{\ensuremath{[\![}}
\newcommand{\rsem}{\ensuremath{]\!]}}
\newcommand{\sem}[1]{\ensuremath{\lsem #1 \rsem}}

% Partial function
\makeatletter
\newcommand{\pto}{}% just for safety
\DeclareRobustCommand{\pto}{\mathrel{\mathpalette\p@to@gets\to}}
\newcommand{\p@to@gets}[2]{%
  \ooalign{\hidewidth$\m@th#1\mapstochar\mkern5mu$\hidewidth\cr$\m@th#1\to$\cr}%
}
\makeatother

\title{Typing Property Graphs}
\author{Nimo Beeren}


\begin{document}

\section{Property Graphs}

We postulate the following countably infinite sets: the set of labels $\mathcal{L}$, the set of property names $\mathcal{N}$ and the set of property values $\mathcal{V}$.

\begin{definition}[Record]
  A \emph{record} is a finite partial function $r : \mathcal{N} \pto \mathcal{V}$ that maps some property names to property values. The set of all records is denoted as $\mathcal{R}$.
\end{definition}

\begin{definition}[Property graph]
  A \emph{property graph} is a tuple $(N, E_d, E_u, \rho, \lambda, \pi)$ where
  \begin{itemize}
    \item $N$ is a finite set of nodes;
    \item $E_d$ is a finite set of directed edges;
    \item $E_u$ is a finite set of undirected edges;
    % FIXME: could map "directed" edges to unordered pairs and vice versa
    \item $\rho : (E_d \cup E_u) \to (N \times N) \cup \{\{u, v\} \mid u, v \in N\}$ is a total function mapping edges to  ordered or unordered pairs of nodes;
    \item $\lambda : (N \cup E_d \cup E_u) \to 2^{\mathcal{L}}$ is a total function mapping nodes and edges to a (possibly empty) set of labels;
    \item $\pi : (N \cup E_d \cup E_u) \to \mathcal{R}$ is a total function mapping nodes and edges to a record;
    \item the sets $N$, $E_d$, $E_u$ are disjoint.
  \end{itemize}
\end{definition}

Given a node $n$, the set of \emph{outgoing} edges is given by $\{e \in E_d \mid \exists n' \in N : \rho(e) = (n, n')\}$, and the set of \emph{incoming} edges is given by $\{e \in E_d \mid \exists n' \in N : \rho(e) = (n', n)\}$. We use the umbrella term \emph{elements} to refer to nodes and edges.

\section{Property Graph Schemas}

We postulate the set of property types $\mathcal{T}$.

\begin{definition}[Property conformance]
  For each property type $\ptype \in \ptypes$ there is a set $\sem{\ptype} \subseteq \mathcal{V}$ that contains all property values that \emph{conform} to the type $\ptype$.
\end{definition}

\begin{definition}[Record type]
  A \emph{record type} is a finite partial function $\rtype : \mathcal{N} \pto \ptypes$ that maps some property names to a property type. We will denote such record types as $\langle a_1 : \rtype_1, \ldots, a_n : \rtype_n \rangle$.
\end{definition}

\begin{definition}[Record conformance]
  We say that a record $r$ \emph{conforms} to a record type $\rtype$, denoted $r \in \sem{\rtype}$, if for each property name $k \in \mathcal{N}$ it holds that (1) $r(k)$ is defined iff $\rtype(k)$ is defined and (2) $r(k) \in \sem{\rtype(k)}$ if $r(k)$ and $\rtype(k)$ are defined.
\end{definition}

Next, we introduce an \emph{element type}\footnote{We typically use the symbol \emph{b} to refer to elements, since \emph{e} is reserved for edges.}, which describes the labels and properties that can be associated with a node or edge.

\begin{definition}[Element type]
  A \emph{element type} is a pair $\btype = (L, \rtype)$ where $L \subseteq \mathcal{L}$ is a finite set of labels and and $\rtype$ a record type. We will denote such element types also simply as $L\rtype$ or $\{ l_1 \ldots l_k \} \langle a_1 : \rtype_1, \ldots, a_n : \rtype_n \rangle$. The set of all element types is denoted as $\btypes$.
\end{definition}

\begin{definition}[Element conformance]
  Let $G = (N, E_d, E_u, \rho, \lambda, \pi)$ be a property graph and $\btype = L\rtype$ an element type. The set of elements that \emph{conform} to $\btype$ is defined as $\sem{\btype} = \{b \in N \cup E_d \cup E_u \mid \lambda(b) = L \wedge \pi(b) \in \sem{\rtype}\}$.
\end{definition}

\begin{definition}[Property graph type]
  A \emph{property graph type} is given by a tuple $\gtype = (N, E_d, E_u, \rho, \beta)$ where 
  \begin{itemize}
    \item $N$ is a finite set of schema nodes;
    \item $E_d$ is a finite set of directed schema edges;
    \item $E_u$ is a finite set of undirected schema edges;
    \item $\rho : (E_d \cup E_u) \to (N \times N) \cup \{\{u, v\} \mid u, v \in N\}$ is a total function mapping schema edges to ordered or unordered pairs of schema nodes;
    \item $\beta : (N \cup E_d \cup E_u) \to \btypes$ is a total function mapping schema elements to element types;
    \item the sets $N$, $E_d$ and $E_u$ are disjoint.
  \end{itemize}
\end{definition}

The similarity between property graph types and property graphs is intentional. This allows us to visualize them in a similar ways, and to use the same mental model to think about them. Indeed, a property graph type can be simulated by a property graph if we allow properties to take property types as values, i.e. $\ptypes \subseteq \mathcal{V}$. Then we let $\lambda$ and $\pi$ take the role of $\beta$, in the sense that $\lambda(b) = L$ and $\pi(b) = \rtype$ if $\beta(b) = L\rtype$ for all elements $b$ of the property graph.

\begin{definition}[Property graph conformance]
  We say that a property graph $G = (N, E_d, E_u, \rho, \lambda, \pi)$ \emph{conforms} to a property graph type $\gtype = (N', E_d', E_u', \rho', \beta)$ if and only if all of the following rules hold.

  \begin{enumerate}
    \item The vocabulary for nodes:\\
    $\forall n \in N \exists n' \in N' : n \in \sem{\beta(n')}$
    
    \item The vocabulary for directed edges:\\
    $\forall e \in E_d \exists e' \in E_d' : e \in \sem{\beta(e')}$

    \item The vocabulary for undirected edges:\\
    $\forall e \in E_u \exists e' \in E_u' : e \in \sem{\beta(e')}$
    
    \item Outgoing directed edges are mandatory:\\
    $\forall e' \in E_d' \forall n'_1, n'_2 \in N' : \rho'(e') = (n'_1, n'_2) \implies
    \\\forall n_1 \in N \cap \sem{\beta(n'_1)} \exists e \in E_d \cap \sem{\beta(e')} \exists n_2 \in N \cap \sem{\beta(n'_2)} : \rho(e) = (n_1, n_2)$

    \item Incoming directed edges are mandatory:\\
    $\forall e' \in E_d' \forall n'_1, n'_2 \in N' : \rho'(e') = (n'_1, n'_2) \implies
    \\\forall n_2 \in N \cap \sem{\beta(n'_2)} \exists e \in E_d \cap \sem{\beta(e')} \exists n_1 \in N \cap \sem{\beta(n'_1)} : \rho(e) = (n_1, n_2)$
    
    \item Undirected edges are mandatory:\\
    $\forall e' \in E_u' \forall n'_1, n'_2 \in N' : \rho'(e') = \{n'_1, n'_2\} \implies
    \\\forall n_1 \in N \cap \sem{\beta(n'_1)} \exists e \in E_u \cap \sem{\beta(e')} \exists n_2 \in N \cap \sem{\beta(n'_2)} : \rho(e) = \{n_1, n_2\}$
  \end{enumerate}
\end{definition}

Under these definitions, all edges in the schema are mandatory. That is, if a schema node $n' \in N'$ has an incident edge $e'$ (i.e. an incoming, outgoing, or undirected edge that $n'$ participates in), then any node $n \in N$ that conforms to $\beta(n')$ must also have one or more incident edges $e$ (in the same direction) that conform to $\beta(e')$. Furthermore, the other endpoint of $e$ must conform to the element type associated with the other endpoint of the schema edge. In the following, we will relax this requirement and introduce more general constraints on cardinality.

\subsection{Cardinality constraints}

We first introduce a generalization of the existential quantifier, which enables counting the number of distinct variables that satisfy a predicate.

\begin{definition}[Counting quantifier]
  The \emph{counting quantifier} is defined as follows. Given two numbers $n, m \in \N$, a predicate $P$, and a set $X$, define
  \begin{itemize}
    \item $\exists^{\geq n} x \in X : P(x) \equiv \exists x_1, x_2, \ldots, x_n \in X : P(x_1) \wedge \ldots \wedge P(x_n) \wedge \forall 1 \leq i < j \leq n : x_i \neq x_j$;
    \item $\exists^{\leq n} x \in X : P(x) \equiv \exists x_1, \ldots, x_n, x_{n+1}, \ldots, x_k \in X : P(x) \implies \forall n < i < j \leq k : x_i = x_j$;
    \item $\exists^{(n, m)} x \in X : P(x) \equiv \exists^{\geq n} x \in X : P(x) \wedge \exists^{\leq m} x' \in X : P(x')$; and
    \item $\exists^{(n, \infty)} x \in X : P(x) \equiv \exists^{\geq n} x \in X : P(x)$.
  \end{itemize}
\end{definition}

To enable more general cardinality constraints on edges, we revise the definitions of property graph type and property graph conformance.

\begin{definition}[Property graph type]
  A \emph{property graph type} is given by a tuple $\gtype = (N, E_d, E_u, \rho, \beta, \gamma)$ where 
  \begin{itemize}
    \item $N$ is a finite set of schema nodes;
    \item $E_d$ is a finite set of directed schema edges;
    \item $E_u$ is a finite set of undirected schema edges;
    \item $\rho : (E_d \cup E_u) \to (N \times N) \cup \{\{u, v\} \mid u, v \in N\}$ is a total function mapping schema edges to ordered or unordered pairs of schema nodes;
    \item $\beta : (N \cup E_d \cup E_u) \to \btypes$ is a total function mapping schema elements to element types;
    \item $\gamma : (N \times E) \pto (\N \times \N^\infty)$ is a partial function mapping some pairs of schema nodes and schema edges to cardinality constraints, where $\N$ is defined as $\{0, 1, 2, \ldots\}$ and $\N^\infty$ is defined as $\N \cup \{\infty\}$.
  \end{itemize}
  Given a node $n \in N$ and an edge $e \in E$, we assume that $\gamma(n, e)$ is defined if and only if there exists a node $n' \in N$ such that $\rho(e) \in \{(n, n'), (n', n), \{n, n'\}\}$. In other words, $n$ \emph{participates} in $e$.
\end{definition}

\begin{definition}[Property graph conformance]
  We say that a property graph $G = (N, E_d, E_u, \rho, \lambda, \pi)$ \emph{conforms} to a property graph type $\gtype = (N', E_d', E_u', \rho', \beta, \gamma)$ if and only if all of the following rules hold.

  \begin{enumerate}
    \item The vocabulary for nodes:\\
    $\forall n \in N \exists n' \in N' : n \in \sem{\beta(n')}$
    
    \item The vocabulary for directed edges:\\
    $\forall e \in E_d \exists e' \in E_d' : e \in \sem{\beta(e')}$

    \item The vocabulary for undirected edges:\\
    $\forall e \in E_u \exists e' \in E_u' : e \in \sem{\beta(e')}$
    
    \item Cardinality constraints on outgoing directed edges:\\
    $\forall e' \in E_d' \forall n'_1, n'_2 \in N' : \rho'(e') = (n'_1, n'_2) \implies
    \\\forall n_1 \in N \cap \sem{\beta(n'_1)} \exists^{\gamma(n'_1, e')} e \in E_d \cap \sem{\beta(e')} \exists n_2 \in N \cap \sem{\beta(n'_2)} : \rho(e) = (n_1, n_2)$

    \item Cardinality constraints on incoming directed edges:\\
    $\forall e' \in E_d' \forall n'_1, n'_2 \in N' : \rho'(e') = (n'_1, n'_2) \implies
    \\\forall n_2 \in N \cap \sem{\beta(n'_2)} \exists^{\gamma(n'_2, e')} e \in E_d \cap \sem{\beta(e')} \exists n_1 \in N \cap \sem{\beta(n'_1)} : \rho(e) = (n_1, n_2)$
    
    \item Cardinality constraints on undirected edges:\\
    $\forall e' \in E_u' \forall n'_1, n'_2 \in N' : \rho'(e') = \{n'_1, n'_2\} \implies
    \\\forall n_1 \in N \cap \sem{\beta(n'_1)} \exists^{\gamma(n'_1, e')} e \in E_u \cap \sem{\beta(e')} \exists n_2 \in N \cap \sem{\beta(n'_2)} : \rho(e) = \{n_1, n_2\}$
  \end{enumerate}
\end{definition}

% TODO: optional properties
% TODO: "any" types, i.e. record with any property, allow edge to any node

\end{document}
