\documentclass[a4paper]{article}

\usepackage[hidelinks]{hyperref}
\usepackage{parskip}
\usepackage{amsmath}
\usepackage{amssymb}

\newtheorem{theorem}{Theorem}
\newtheorem{definition}[theorem]{Definition}
\newtheorem{note}[theorem]{Note}
\newtheorem{example}[theorem]{Example}

% Natural numbers
\newcommand{\N}{\mathbb{N}}

% Partial function
\makeatletter
\newcommand{\pto}{}% just for safety
\DeclareRobustCommand{\pto}{\mathrel{\mathpalette\p@to@gets\to}}
\newcommand{\p@to@gets}[2]{%
  \ooalign{\hidewidth$\m@th#1\mapstochar\mkern5mu$\hidewidth\cr$\m@th#1\to$\cr}%
}
\makeatother

% Projection operator
\newcommand{\proj}{\mathrm{proj}}

% Schema elements
\newcommand{\ptype}{\tau}
\newcommand{\ptypes}{\mathcal{T}}
\newcommand{\rtype}{\tau^\mathsf{r}}
\newcommand{\rtypes}{\mathcal{T}^\mathsf{r}}
\newcommand{\otype}{\tau^\mathsf{o}}
\newcommand{\otypes}{\mathcal{T}^\mathsf{o}}
\newcommand{\gtype}{\tau^\mathsf{g}}
\newcommand{\gtypes}{\mathcal{T}^\mathsf{g}}

% Semantics (double brackets)
\newcommand{\lsem}{\ensuremath{[\![}}
\newcommand{\rsem}{\ensuremath{]\!]}}
\newcommand{\sem}[1]{\ensuremath{\lsem #1 \rsem}}

% Undefined
\newcommand{\undefined}{\mathbf{undef}}

\title{Typing Property Graphs}
\author{Nimo Beeren}


\begin{document}

\section{Property Graphs}

We postulate the following countably infinite sets: the set of labels $\mathcal{L}$, the set of property names $\mathcal{N}$ and the set of property values $\mathcal{V}$.

\begin{definition}[Record]
  A \emph{record} is a finite partial function $r : \mathcal{N} \pto \mathcal{V}$ that maps some property names to property values. The set of all records is denoted as $\mathcal{R}$.
\end{definition}

\begin{definition}[Property graph]
  A \emph{property graph} is a tuple $$G = (N, E, \rho, \lambda, \pi)$$ where
  \begin{itemize}
    \item $N$ is a finite set of nodes;
    \item $E$ is a finite set of edges such that $N \cap E = \emptyset$;
    \item $\rho : E \to (N \times N)$ is a total function mapping edges to ordered pairs of nodes;
    \item $\lambda : (N \cup E) \to 2^{\mathcal{L}}$ is a total function mapping nodes and edges to a (possibly empty) set of labels;
    \item $\pi : (N \cup E) \to \mathcal{R}$ is a total function mapping nodes and edges to a record.
  \end{itemize}
\end{definition}

Our notion of property graph is a directed \emph{multigraph}. That means there can be multiple edges between two nodes $u$ and $v$. Furthermore, we allow $u = v$, in which case the edge is called a \emph{self-loop}. Undirected edges are not allowed, but they could be simulated by attaching a special label or property to an edge.

Given a node $u$, the set of \emph{outgoing} edges is given by $\{e \in E \mid \exists v \in N : \rho(e) = (u, v)\}$, and the set of \emph{incoming} edges is given by $\{e \in E \mid \exists v \in N : \rho(e) = (v, u)\}$. We use the umbrella term \emph{objects} to refer to nodes and edges.

The $j^\text{th}$ \emph{projection map}, written $\proj_j$, maps a tuple $\bar{x} = (x_1, \ldots, x_j, \ldots, x_k)$ to the value $\proj_j(\bar{x}) = x_j$.

\section{Property Graph Schemas}

We postulate the set of property types $\mathcal{T}$.

\begin{definition}[Property conformance]
  For each property type $\ptype \in \ptypes$ there is a set $\sem{\ptype} \subseteq \mathcal{V}$ that contains all property values that \emph{conform} to the type $\ptype$.
\end{definition}

\begin{definition}[Record type]
  A \emph{record type} is a finite partial function $\rtype : \mathcal{N} \pto \ptypes$ that maps some property names to a property type.
  We will denote such record types as $\langle a_1 : \ptype_1, \ldots, a_n : \ptype_n \rangle$.
\end{definition}

\begin{definition}[Record conformance]
  We say that a record $r$ \emph{conforms} to a record type $\rtype$, denoted $r \in \sem{\rtype}$, if for each property name $k \in \mathcal{N}$ it holds that (1) $r(k)$ is defined iff $\rtype(k)$ is defined and (2) $r(k) \in \sem{\rtype(k)}$ if $r(k)$ and $\rtype(k)$ are defined.
\end{definition}

\begin{definition}[Object type]
  A \emph{object type} is a pair $\otype = (L, \rtype)$ where $L \subseteq \mathcal{L}$ is a finite set of labels and and $\rtype$ a record type. 
  % We will denote such object types also simply as $L\rtype$ or $\{ l_1 \ldots l_k \} \langle a_1 : \rtype_1, \ldots, a_n : \rtype_n \rangle$.
  The set of all object types is denoted as $\otypes$.
\end{definition}

\begin{definition}[Object conformance]
  Let $G = (N, E, \rho, \lambda, \pi)$ be a property graph and $\otype = (L, \rtype)$ an object type. The set of objects that \emph{conform} to $\otype$ is defined as $\sem{\otype} = \{o \in N \cup E \mid \lambda(o) = L \wedge \pi(o) \in \sem{\rtype}\}$.
\end{definition}

\begin{definition}[Property graph type]
  A \emph{property graph type} is given by a tuple $\gtype = (N, E, \rho, \omega)$ where 
  \begin{itemize}
    \item $N$ is a finite set of schema nodes;
    \item $E$ is a finite set of schema edges such that $N \cap E = \emptyset$;
    \item $\rho : E \to (N \times N)$ is a total function mapping schema edges to ordered pairs of schema nodes;
    \item $\omega : (N \cup E) \to \otypes$ is a total function mapping schema objects to object types;
  \end{itemize}
\end{definition}

The similarity between property graph types and property graphs is intentional. This allows us to visualize them in a similar ways, and to use the same mental model to think about them. Indeed, a property graph type can be simulated by a property graph if we allow properties to take property types as values, i.e. $\ptypes \subseteq \mathcal{V}$. Then we let $\lambda$ and $\pi$ take the role of $\omega$, in the sense that $\lambda(o) = L$ and $\pi(o) = \rtype$ if $\omega(o) = (L, \rtype)$ for all objects $o$ in the property graph.

\begin{definition}[Property graph conformance]
  Given a property graph $$G = (N, E, \rho, \lambda, \pi)$$ and a property graph type $$\gtype = (N', E', \rho', \omega)$$ we say that $G$ \emph{conforms} to $\gtype$ if and only if all of the following rules hold.

  % TODO: don't like this "vocabulary" word
  \begin{enumerate}
    \item The vocabulary for nodes:
    \begin{align*}
      &\forall n \in N \exists n' \in N'\\
      &\quad n \in \sem{\omega(n')}
    \end{align*}
    
    \item The vocabulary for edges:
    \begin{align*}
      &\forall e \in E \exists e' \in E'\\
      &\quad e \in \sem{\omega(e')}\\
      &\quad\quad\wedge \proj_1(\rho(e)) \in \sem{\omega(\proj_1(\rho'(e')))}\\
      &\quad\quad\wedge \proj_2(\rho(e)) \in \sem{\omega(\proj_2(\rho'(e')))}
    \end{align*}
    
    \item Outgoing edges are mandatory:
    \begin{align*}
      &\forall e' \in E' \forall n_1 \in N \cap \sem{\omega(\proj_1(\rho(e')))}\\
      &\quad\exists e \in E \cap \sem{\omega(e')}\\
      &\quad\quad \proj_1(\rho(e)) = n_1 \wedge \proj_2(\rho(e)) \in \sem{\omega(\proj_2(\rho(e')))}
    \end{align*}

    \item Incoming edges are mandatory:
    \begin{align*}
      &\forall e' \in E' \forall n_2 \in N \cap \sem{\omega(\proj_2(\rho(e')))}\\
      &\quad\exists e \in E \cap \sem{\omega(e')}\\
      &\quad\quad \proj_1(\rho(e)) \in \sem{\omega(\proj_1(\rho(e')))} \wedge \proj_2(\rho(e)) = n_2
    \end{align*}
  \end{enumerate}
\end{definition}

Under these definitions, a schema edge requires that at least one conforming edge exists in the data graph. That is, if a schema node $n' \in N'$ has an incident edge $e'$ (i.e. an incoming or outgoing edge that $n'$ participates in), then any node $n \in N$ that conforms to $\omega(n')$ must also have at least one incident edge $e$ (in the same direction) that conforms to $\omega(e')$. Furthermore, the other endpoint of $e$ must conform to the object type associated with the other endpoint of the schema edge.

In the following, we will relax this requirement and introduce more general constraints on cardinality.

\subsection{Cardinality constraints}

We first introduce a generalization of the existential quantifier, which enables counting the number of distinct variables that satisfy a predicate.

% TODO: use dots to denote ranges and * instead of \infty
\begin{definition}[Counting quantifier]
  The \emph{counting quantifier} is defined as follows. Given two numbers $n, m \in \N$, a predicate $P$, and a set $X$, define
  \begin{itemize}
    \item $\exists^{\geq n} x \in X : P(x) \equiv \exists x_1, x_2, \ldots, x_n \in X : P(x_1) \wedge \ldots \wedge P(x_n) \wedge \forall 1 \leq i < j \leq n : x_i \neq x_j$;
    \item $\exists^{\leq n} x \in X : P(x) \equiv \exists x_1, \ldots, x_n, x_{n+1}, \ldots, x_k \in X : P(x) \implies \forall n < i < j \leq k : x_i = x_j$;
    \item $\exists^{(n, m)} x \in X : P(x) \equiv \exists^{\geq n} x \in X : P(x) \wedge \exists^{\leq m} x' \in X : P(x')$; and
    \item $\exists^{(n, \infty)} x \in X : P(x) \equiv \exists^{\geq n} x \in X : P(x)$.
  \end{itemize}
\end{definition}

To enable more general cardinality constraints on edges, we revise the definitions of property graph type and property graph conformance.

\begin{definition}[Property graph type]
  A \emph{property graph type} is a tuple $$\gtype = (N, E, \rho, \omega, \gamma)$$ where
  \begin{itemize}
    \item $N$ is a finite set of schema nodes;
    \item $E$ is a finite set of schema edges such that $N \cap E = \emptyset$;
    \item $\rho : E \to (N \times N)$ is a total function mapping schema edges to ordered pairs of schema nodes;
    \item $\omega : (N \cup E) \to \otypes$ is a total function mapping schema objects to object types;
    % TODO: let gamma map edges to an ordered pair of cardinality constraints
    \item $\gamma : (N \times E) \pto (\N \times \N^\infty)$ is a partial function mapping some pairs of schema nodes and schema edges to cardinality constraints, where $\N$ is defined as $\{0, 1, 2, \ldots\}$ and $\N^\infty$ is defined as $\N \cup \{\infty\}$;
  \end{itemize}

  % TODO: add some explanation on what a "cardinality constraint" is

  Given a node $n \in N$ and an edge $e \in E$, we assume that $\gamma(n, e)$ is defined if and only if $n$ \emph{participates} in $e$. That is to say that there exists a node $n' \in N$ such that $\rho(e) = (n, n')$ or $\rho(e) = (n', n)$.
\end{definition}

\begin{definition}[Property graph conformance]
  Given a property graph $$G = (N, E, \rho, \lambda, \pi)$$ and a property graph type $$\gtype = (N', E', \rho', \omega, \gamma)$$ we say that $G$ \emph{conforms} to $\gtype$ if and only if all of the following rules hold.

  \begin{enumerate}
    \item The vocabulary for nodes:
    \begin{align*}
      &\forall n \in N \exists n' \in N'\\
      &\quad n \in \sem{\omega(n')}
    \end{align*}
    
    \item The vocabulary for edges:
    \begin{align*}
      &\forall e \in E \exists e' \in E'\\
      &\quad e \in \sem{\omega(e')}\\
      &\quad\quad\wedge \proj_1(\rho(e)) \in \sem{\omega(\proj_1(\rho'(e')))}\\
      &\quad\quad\wedge \proj_2(\rho(e)) \in \sem{\omega(\proj_2(\rho'(e')))}
    \end{align*}
    
    \item Cardinality constraints on outgoing edges:
    \begin{align*}
      &\forall e' \in E' \forall n_1 \in N \cap \sem{\omega(\proj_1(\rho(e')))}\\
      &\quad\exists^{\gamma(n'_1, e')} e \in E \cap \sem{\omega(e')}\\
      &\quad\quad \proj_1(\rho(e)) = n_1 \wedge \proj_2(\rho(e)) \in \sem{\omega(\proj_2(\rho(e')))}
    \end{align*}

    \item Cardinality constraints on incoming edges:
    \begin{align*}
      &\forall e' \in E' \forall n_2 \in N \cap \sem{\omega(\proj_2(\rho(e')))}\\
      &\quad\exists^{\gamma(n'_2, e')} e \in E \cap \sem{\omega(e')}\\
      &\quad\quad \proj_1(\rho(e)) \in \sem{\omega(\proj_1(\rho(e')))} \wedge \proj_2(\rho(e)) = n_2
    \end{align*}
  \end{enumerate}
\end{definition}

\subsection{Optional properties}

We revise the definition of record by adding a special property value $\undefined$, which indicates that the value of a property is not defined.

\begin{definition}[Record]
  A \emph{record} is a total function $r : \mathcal{N} \to \mathcal{V} \cup \{\undefined\}$ that maps property names to property values or the special value $\undefined$. The set of all records is denoted as $\mathcal{R}$.
\end{definition}

For a record $r$ and a property name $k \in \mathcal{N}$ such that $r(k)$ was previously undefined, we now say $r(k) = \undefined$. This can be seen as the ``default'' value of a property.

We adjust the definitions of property conformance, record type, and record conformance accordingly.

\begin{definition}[Property conformance]
  For each property type $\ptype \in \ptypes$ there is a set $\sem{\ptype} \subseteq \mathcal{V} \cup \{\undefined\}$ that contains all property values that \emph{conform} to the type $\ptype$. We say $\ptype$ is \emph{optional} iff $\undefined \in \sem{\ptype}$. We use the notation $\ptype?$ to make a property optional, i.e. $\sem{\ptype?} = \sem{\ptype} \cup \{ \undefined \}$.
\end{definition}

\begin{definition}[Record type]
  A \emph{record type} is a total function $\rtype : \mathcal{N} \to \ptypes$ that maps property names to a property type.
  % We will denote such record types as $\langle a_1 : \rtype_1, \ldots, a_n : \rtype_n \rangle$.
\end{definition}

\begin{definition}[Record conformance]
  We say that a record $r$ \emph{conforms} to a record type $\rtype$, denoted $r \in \sem{\rtype}$, if and only if for each property name $k \in \mathcal{N}$ it holds that $r(k) \in \sem{\rtype(k)}$.
\end{definition}

\subsection{Open Records}

It may be desirable to allow a record to have properties with any name or any value. Such \emph{open records} can already be expressed under the current definitions. For a record type $\rtype$, we can allow properties with any name by setting $\rtype(k) = \ptype?$ for all (previously unspecified) property names $k \in \mathcal{N}$, where $\ptype$ is an arbitrary property type. Note that there may be infinitely many such $k$, so in we may want to have a special syntax to express this. We can allow these properties to have any value by setting $\sem{\ptype} = \mathcal{V}$, or we can restrict them to a subset of $\mathcal{V}$.

\section{Limitations}

Under these definitions, it is not possible to specify constraints over a graph pattern larger than two neighboring nodes and the edge between them. For example, we cannot express that if a \texttt{Person} node has an outgoing edge \texttt{OWNS} to a \texttt{Car} node, then that \texttt{Person} node must have an outgoing edge \texttt{HAS} to a \texttt{DriversLicense} node. Such a pattern consists of three nodes (\texttt{Person}, \texttt{Car}, \texttt{DriversLicense}) and two edges (\texttt{OWNS}, \texttt{HAS}).

Alternatively, we can have two \texttt{Person} nodes, where one requires having a \texttt{DriversLicense} and allows owning 0 or more \texttt{Car}s, and the other does not allow owning a \texttt{Car}. This would indeed prevent a situation where a \texttt{Person} owns a \texttt{Car}, but does not have a \texttt{DriversLicense}. However, ...

% However, this breaks down when we add constraints that depend on the uniqueness of a \texttt{Person}. For example, say we want to model that a Person has exactly one Passport, and every Passport is associated with exactly one Person.
% FIXME: actually, this seems possible, as long as everything is the same for both Person nodes

% Node with any label: create a node for every combination of labels (but then we can't express there should be an edge to "at least one" of them). Solution: union types? Look into type theory again

Furthermore, it is not possible to have a single object type that allows two different label sets. Hence, it is not possible to have optional labels, i.e. the object type $\otype = (\{\texttt{Vehicle}, \texttt{Car}\}, \langle \texttt{make} : \texttt{string} \rangle)$ requires that the labels \texttt{Vehicle} and \texttt{Car} are both present, just having \texttt{Car} is not enough. Of course, it is possible to have two schema objects like $\otype_1 = (\{\texttt{Car}\}, \langle \texttt{make} : \texttt{string} \rangle)$ and $\otype_2 = (\{\texttt{Vehicle}, \texttt{Car}\}, \langle \texttt{make} : \texttt{string} \rangle)$. However, then it is not possible to specify that every \texttt{Employee} must have exactly one outgoing \texttt{OWNS} edge to a node conforming to either $\otype_1$ or $\otype_2$.

% TODO: In general, it's not possible to say that an object must conform to type 1 OR type 2 (union type). Problem with labels follows from that. But also union of two records is not possible.

\end{document}
