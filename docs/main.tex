\documentclass[a4paper]{article}

\usepackage[hidelinks]{hyperref}
\usepackage{parskip}
\usepackage{amsmath}
\usepackage{amssymb}

\newtheorem{theorem}{Theorem}
\newtheorem{definition}[theorem]{Definition}
\newtheorem{note}[theorem]{Note}
\newtheorem{example}[theorem]{Example}

% Natural numbers
\newcommand{\N}{\mathbb{N}}

% Partial function
\makeatletter
\newcommand{\pto}{}% just for safety
\DeclareRobustCommand{\pto}{\mathrel{\mathpalette\p@to@gets\to}}
\newcommand{\p@to@gets}[2]{%
  \ooalign{\hidewidth$\m@th#1\mapstochar\mkern5mu$\hidewidth\cr$\m@th#1\to$\cr}%
}
\makeatother

% Schema elements
\newcommand{\ptype}{\tau}
\newcommand{\ptypes}{\mathcal{T}}
\newcommand{\rtype}{\tau^r}
\newcommand{\rtypes}{\mathcal{T}^r}
\newcommand{\otype}{\tau^o}
\newcommand{\otypes}{\mathcal{T}^o}
\newcommand{\gtype}{\tau^g}
\newcommand{\gtypes}{\mathcal{T}^g}

% Semantics (double brackets)
\newcommand{\lsem}{\ensuremath{[\![}}
\newcommand{\rsem}{\ensuremath{]\!]}}
\newcommand{\sem}[1]{\ensuremath{\lsem #1 \rsem}}

% Undefined
\newcommand{\undefined}{\mathbf{undef}}

\title{Typing Property Graphs}
\author{Nimo Beeren}


\begin{document}

\section{Property Graphs}

We postulate the following countably infinite sets: the set of labels $\mathcal{L}$, the set of property names $\mathcal{N}$ and the set of property values $\mathcal{V}$.

\begin{definition}[Record]
  A \emph{record} is a finite partial function $r : \mathcal{N} \pto \mathcal{V}$ that maps some property names to property values. The set of all records is denoted as $\mathcal{R}$.
\end{definition}

\begin{definition}[Property graph]
  A \emph{property graph} is a tuple \[G = (N, E_d, E_u, \rho_d, \rho_u, \lambda, \pi)\] where
  \begin{itemize}
    \item $N$ is a finite set of nodes;
    \item $E_d$ is a finite set of directed edges;
    \item $E_u$ is a finite set of undirected edges;
    \item $\rho_d : E_d \to (N \times N)$ is a total function mapping directed edges to ordered pairs of nodes;
    \item $\rho_u : E_u \to \{\{u, v\} \mid u, v \in N\}$ is a total function mapping undirected edges to unordered pairs of nodes;
    \item $\lambda : (N \cup E_d \cup E_u) \to 2^{\mathcal{L}}$ is a total function mapping nodes and edges to a (possibly empty) set of labels;
    \item $\pi : (N \cup E_d \cup E_u) \to \mathcal{R}$ is a total function mapping nodes and edges to a record;
    \item the sets $N$, $E_d$, $E_u$ are disjoint.
  \end{itemize}
\end{definition}

Given a node $n$, the set of (directed) \emph{outgoing} edges is given by $\{e \in E_d \mid \exists n' \in N : \rho_d(e) = (n, n')\}$, and the set of (directed) \emph{incoming} edges is given by $\{e \in E_d \mid \exists n' \in N : \rho_d(e) = (n', n)\}$. We use the umbrella term \emph{objects} to refer to nodes and edges.

\section{Property Graph Schemas}

We postulate the set of property types $\mathcal{T}$.

\begin{definition}[Property conformance]
  For each property type $\ptype \in \ptypes$ there is a set $\sem{\ptype} \subseteq \mathcal{V}$ that contains all property values that \emph{conform} to the type $\ptype$.
\end{definition}

\begin{definition}[Record type]
  A \emph{record type} is a finite partial function $\rtype : \mathcal{N} \pto \ptypes$ that maps some property names to a property type.
  We will denote such record types as $\langle a_1 : \ptype_1, \ldots, a_n : \ptype_n \rangle$.
\end{definition}

\begin{definition}[Record conformance]
  We say that a record $r$ \emph{conforms} to a record type $\rtype$, denoted $r \in \sem{\rtype}$, if for each property name $k \in \mathcal{N}$ it holds that (1) $r(k)$ is defined iff $\rtype(k)$ is defined and (2) $r(k) \in \sem{\rtype(k)}$ if $r(k)$ and $\rtype(k)$ are defined.
\end{definition}

\begin{definition}[Object type]
  A \emph{object type} is a pair $\otype = (L, \rtype)$ where $L \subseteq \mathcal{L}$ is a finite set of labels and and $\rtype$ a record type. 
  % We will denote such object types also simply as $L\rtype$ or $\{ l_1 \ldots l_k \} \langle a_1 : \rtype_1, \ldots, a_n : \rtype_n \rangle$.
  The set of all object types is denoted as $\otypes$.
\end{definition}

\begin{definition}[Object conformance]
  Let $G = (N, E_d, E_u, \rho_d, \rho_u, \lambda, \pi)$ be a property graph and $\otype = (L, \rtype)$ an object type. The set of objects that \emph{conform} to $\otype$ is defined as $\sem{\otype} = \{o \in N \cup E_d \cup E_u \mid \lambda(o) = L \wedge \pi(o) \in \sem{\rtype}\}$.
\end{definition}

\begin{definition}[Property graph type]
  A \emph{property graph type} is given by a tuple $\gtype = (N, E_d, E_u, \rho_d, \rho_u, \omega)$ where 
  \begin{itemize}
    \item $N$ is a finite set of schema nodes;
    \item $E_d$ is a finite set of directed schema edges;
    \item $E_u$ is a finite set of undirected schema edges;
    \item $\rho_d : E_d \to (N \times N)$ is a total function mapping directed schema edges to ordered pairs of schema nodes;
    \item $\rho_u : E_u \to \{\{u, v\} \mid u, v \in N\}$ is a total function mapping undirected schema edges to unordered pairs of schema nodes;
    \item $\omega : (N \cup E_d \cup E_u) \to \otypes$ is a total function mapping schema objects to object types;
    \item the sets $N$, $E_d$ and $E_u$ are disjoint.
  \end{itemize}
\end{definition}

The similarity between property graph types and property graphs is intentional. This allows us to visualize them in a similar ways, and to use the same mental model to think about them. Indeed, a property graph type can be simulated by a property graph if we allow properties to take property types as values, i.e. $\ptypes \subseteq \mathcal{V}$. Then we let $\lambda$ and $\pi$ take the role of $\omega$, in the sense that $\lambda(o) = L$ and $\pi(o) = \rtype$ if $\omega(o) = (L, \rtype)$ for all objects $o$ in the property graph.

% TODO: mirror the changes on later definition of PG conformance
\begin{definition}[Property graph conformance]
  We say that a property graph \[G = (N, E_d, E_u, \rho_d, \rho_u, \lambda, \pi)\] \emph{conforms} to a property graph type \[\gtype = (N', E_d', E_u', \rho_d', \rho_u', \omega)\] if and only if all of the following rules hold.

  % TODO: don't like this "vocabulary" word
  \begin{enumerate}
    \item The vocabulary for nodes:
    \begin{align*}
      &\forall n \in N \exists n' \in N'\\
      &\quad n \in \sem{\omega(n')}
    \end{align*}
    
    \item The vocabulary for directed edges:
    \begin{align*}
      &\forall e \in E_d \exists e' \in E_d'\\
      &\quad e \in \sem{\omega(e')}\\
      &\quad\wedge \Pi_1(\rho_d(e)) \in \sem{\omega(\Pi_1(\rho_d'(e')))}\\
      &\quad\wedge \Pi_2(\rho_d(e)) \in \sem{\omega(\Pi_2(\rho_d'(e')))}
    \end{align*}

    % FIXME: \Pi on a set does not make sense
    \item The vocabulary for undirected edges:
    \begin{align*}
      &\forall e \in E_u \exists e' \in E_u'\\
      &\quad e \in \sem{\omega(e')}\\
      &\quad\wedge \Pi_1(\rho_u(e)) \in \sem{\omega(\Pi_1(\rho_u'(e')))}\\
      &\quad\wedge \Pi_2(\rho_u(e)) \in \sem{\omega(\Pi_2(\rho_u'(e')))}
    \end{align*}
    
    \item Outgoing directed edges are mandatory:
    \begin{align*}
      &\forall e' \in E_d' \forall n'_1, n'_2 \in N'\\
      &\quad\rho_d'(e') = (n'_1, n'_2)\\
      &\quad\quad\implies {} \forall n_1 \in N \cap \sem{\omega(n'_1)} \exists e \in E_u \cap \sem{\omega(e')} \exists n_2 \in N \cap \sem{\omega(n'_2)}\\
      &\quad\quad\quad\quad\quad\quad\rho_d(e) = (n_1, n_2)
    \end{align*}

    \item Incoming directed edges are mandatory:
    \begin{align*}
      &\forall e' \in E_d' \forall n'_1, n'_2 \in N'\\
      &\quad\rho_d'(e') = (n'_1, n'_2)\\
      &\quad\quad\implies {} \forall n_2 \in N \cap \sem{\omega(n'_2)} \exists e \in E_u \cap \sem{\omega(e')} \exists n_1 \in N \cap \sem{\omega(n'_1)}\\
      &\quad\quad\quad\quad\quad\quad\rho_d(e) = (n_1, n_2)
    \end{align*}
    
    \item Undirected edges are mandatory:
    \begin{align*}
      &\forall e' \in E_u' \forall n'_1, n'_2 \in N'\\
      &\quad\rho_u'(e') = \{n'_1, n'_2\}\\
      &\quad\quad\implies {} \forall n_1 \in N \cap \sem{\omega(n'_1)} \exists e \in E_u \cap \sem{\omega(e')} \exists n_2 \in N \cap \sem{\omega(n'_2)}\\
      &\quad\quad\quad\quad\quad\quad\rho_u(e) = \{n_1, n_2\}
    \end{align*}
  \end{enumerate}
\end{definition}

Under these definitions, all edges in the schema are mandatory. That is, if a schema node $n' \in N'$ has an incident edge $e'$ (i.e. an incoming, outgoing, or undirected edge that $n'$ participates in), then any node $n \in N$ that conforms to $\omega(n')$ must also have one or more incident edges $e$ (in the same direction) that conform to $\omega(e')$. Furthermore, the other endpoint of $e$ must conform to the object type associated with the other endpoint of the schema edge. In the following, we will relax this requirement and introduce more general constraints on cardinality.

\subsection{Cardinality constraints}

We first introduce a generalization of the existential quantifier, which enables counting the number of distinct variables that satisfy a predicate.

\begin{definition}[Counting quantifier]
  The \emph{counting quantifier} is defined as follows. Given two numbers $n, m \in \N$, a predicate $P$, and a set $X$, define
  \begin{itemize}
    \item $\exists^{\geq n} x \in X : P(x) \equiv \exists x_1, x_2, \ldots, x_n \in X : P(x_1) \wedge \ldots \wedge P(x_n) \wedge \forall 1 \leq i < j \leq n : x_i \neq x_j$;
    \item $\exists^{\leq n} x \in X : P(x) \equiv \exists x_1, \ldots, x_n, x_{n+1}, \ldots, x_k \in X : P(x) \implies \forall n < i < j \leq k : x_i = x_j$;
    \item $\exists^{(n, m)} x \in X : P(x) \equiv \exists^{\geq n} x \in X : P(x) \wedge \exists^{\leq m} x' \in X : P(x')$; and
    \item $\exists^{(n, \infty)} x \in X : P(x) \equiv \exists^{\geq n} x \in X : P(x)$.
  \end{itemize}
\end{definition}

To enable more general cardinality constraints on edges, we revise the definitions of property graph type and property graph conformance.

\begin{definition}[Property graph type]
  A \emph{property graph type} is a tuple \[\gtype = (N, E_d, E_u, \rho_d, \rho_u, \omega, \gamma)\] where
  \begin{itemize}
    \item $N$ is a finite set of schema nodes;
    \item $E_d$ is a finite set of directed schema edges;
    \item $E_u$ is a finite set of undirected schema edges;
    \item $\rho_d : E_d \to (N \times N)$ is a total function mapping directed schema edges to ordered pairs of schema nodes;
    \item $\rho_u : E_u \to \{\{u, v\} \mid u, v \in N\}$ is a total function mapping undirected schema edges to unordered pairs of schema nodes;
    \item $\omega : (N \cup E_d \cup E_u) \to \otypes$ is a total function mapping schema objects to object types;
    \item $\gamma : (N \times (E_d \cup E_u)) \pto (\N \times \N^\infty)$ is a partial function mapping some pairs of schema nodes and schema edges to cardinality constraints, where $\N$ is defined as $\{0, 1, 2, \ldots\}$ and $\N^\infty$ is defined as $\N \cup \{\infty\}$;
    \item the sets $N$, $E_d$, $E_u$ are disjoint.
  \end{itemize}

  % TODO: add some explanation on what a "cardinality constraint" is

  Given a node $n \in N$ and an edge $e \in E_d \cup E_u$, we assume that $\gamma(n, e)$ is defined if and only if $n$ \emph{participates} in $e$. That is to say that there exists a node $n' \in N$ such that $\rho_d(e) = (n, n')$ or $\rho_d(e) = (n', n)$ or $\rho_u(e) = \{n, n'\}$.
\end{definition}

\begin{definition}[Property graph conformance]
  We say that a property graph \[G = (N, E_d, E_u, \rho_d, \rho_u, \lambda, \pi)\] \emph{conforms} to a property graph type \[\gtype = (N', E_d', E_u', \rho_d', \rho_u', \omega, \gamma)\] if and only if all of the following rules hold.

  \begin{enumerate}
    \item The vocabulary for nodes:
    \begin{align*}
      &\forall n \in N \exists n' \in N'\\
      &\quad n \in \sem{\omega(n')}
    \end{align*}
    
    \item The vocabulary for directed edges:
    \begin{align*}
      &\forall e \in E_d \exists e' \in E_d'\\
      &\quad e \in \sem{\omega(e')}
    \end{align*}

    \item The vocabulary for undirected edges:
    \begin{align*}
      &\forall e \in E_u \exists e' \in E_u'\\
      &\quad e \in \sem{\omega(e')}
    \end{align*}
    
    \item Cardinality constraints on outgoing directed edges:
    \begin{align*}
      &\forall e' \in E_d' \forall n'_1, n'_2 \in N'\\
      &\quad\rho_d'(e') = (n'_1, n'_2)\\
      &\quad\quad\implies {} \forall n_1 \in N \cap \sem{\omega(n'_1)} \exists^{\gamma(n'_1, e')} e \in E_u \cap \sem{\omega(e')} \exists n_2 \in N \cap \sem{\omega(n'_2)}\\
      &\quad\quad\quad\quad\quad\quad\rho_d(e) = (n_1, n_2)
    \end{align*}

    \item Cardinality constraints on incoming directed edges:
    \begin{align*}
      &\forall e' \in E_d' \forall n'_1, n'_2 \in N'\\
      &\quad\rho_d'(e') = (n'_1, n'_2)\\
      &\quad\quad\implies {} \forall n_2 \in N \cap \sem{\omega(n'_2)} \exists^{\gamma(n'_2, e')} e \in E_u \cap \sem{\omega(e')} \exists n_1 \in N \cap \sem{\omega(n'_1)}\\
      &\quad\quad\quad\quad\quad\quad\rho_d(e) = (n_1, n_2)
    \end{align*}
    
    \item Cardinality constraints on undirected edges:
    \begin{align*}
      &\forall e' \in E_u' \forall n'_1, n'_2 \in N'\\
      &\quad\rho_u'(e') = \{n'_1, n'_2\}\\
      &\quad\quad\implies {} \forall n_1 \in N \cap \sem{\omega(n'_1)} \exists^{\gamma(n'_1, e')} e \in E_u \cap \sem{\omega(e')} \exists n_2 \in N \cap \sem{\omega(n'_2)}\\
      &\quad\quad\quad\quad\quad\quad\rho_u(e) = \{n_1, n_2\}
    \end{align*}
  \end{enumerate}
\end{definition}

\subsection{Optional properties}

We revise the definition of record by adding a special property value $\undefined$, which indicates that the value of a property is not defined.

\begin{definition}[Record]
  A \emph{record} is a total function $r : \mathcal{N} \to \mathcal{V} \cup \{\undefined\}$ that maps property names to property values or the special value $\undefined$. The set of all records is denoted as $\mathcal{R}$.
\end{definition}

For a record $r$ and a property name $k \in \mathcal{N}$ such that $r(k)$ was previously undefined, we now say $r(k) = \undefined$. This can be seen as the ``default'' value of a property.

We adjust the definitions of property conformance, record type, and record conformance accordingly.

\begin{definition}[Property conformance]
  For each property type $\ptype \in \ptypes$ there is a set $\sem{\ptype} \subseteq \mathcal{V} \cup \{\undefined\}$ that contains all property values that \emph{conform} to the type $\ptype$. We say $\ptype$ is \emph{optional} iff $\undefined \in \sem{\ptype}$. We use the notation $\ptype?$ to make a property optional, i.e. $\sem{\ptype?} = \sem{\ptype} \cup \{ \undefined \}$.
\end{definition}

\begin{definition}[Record type]
  A \emph{record type} is a total function $\rtype : \mathcal{N} \to \ptypes$ that maps property names to a property type.
  % We will denote such record types as $\langle a_1 : \rtype_1, \ldots, a_n : \rtype_n \rangle$.
\end{definition}

\begin{definition}[Record conformance]
  We say that a record $r$ \emph{conforms} to a record type $\rtype$, denoted $r \in \sem{\rtype}$, if and only if for each property name $k \in \mathcal{N}$ it holds that $r(k) \in \sem{\rtype(k)}$.
\end{definition}

\subsection{Open Records}

It may be desirable to allow a record to have properties with any name or any value. Such \emph{open records} can already be expressed under the current definitions. For a record type $\rtype$, we can allow properties with any name by setting $\rtype(k) = \ptype?$ for all (previously unspecified) property names $k \in \mathcal{N}$, where $\ptype$ is an arbitrary property type. Note that there may be infinitely many such $k$, so in we may want to have a special syntax to express this. We can allow these properties to have any value by setting $\sem{\ptype} = \mathcal{V}$, or we can restrict them to a subset of $\mathcal{V}$.

\section{Limitations}

Under these definitions, it is not possible to specify constraints over a graph pattern larger than two neighboring nodes and the edge between them. For example, we cannot express that if a \texttt{Person} node has an outgoing edge \texttt{OWNS} to a \texttt{Car} node, then that \texttt{Person} node must have an outgoing edge \texttt{HAS} to a \texttt{DriversLicense} node. Such a pattern consists of three nodes (\texttt{Person}, \texttt{Car}, \texttt{DriversLicense}) and two edges (\texttt{OWNS}, \texttt{HAS}).

Alternatively, we can have two \texttt{Person} nodes, where one requires having a \texttt{DriversLicense} and allows owning 0 or more \texttt{Car}s, and the other does not allow owning a \texttt{Car}. This would indeed prevent a situation where a \texttt{Person} owns a \texttt{Car}, but does not have a \texttt{DriversLicense}.

% However, this breaks down when we add constraints that depend on the uniqueness of a \texttt{Person}. For example, say we want to model that a Person has exactly one Passport, and every Passport is associated with exactly one Person.
% FIXME: actually, this seems possible, as long as everything is the same for both Person nodes

% Node with any label: create a node for every combination of labels (but then we can't express there should be an edge to "at least one" of them). Solution: union types? Look into type theory again

Under these definitions, it is not possible to have a single object type that allows two different label sets. Hence, it is not possible to have optional labels, i.e. the object type $\otype = (\{\texttt{Vehicle}, \texttt{Car}\}, \langle \texttt{make} : \texttt{string} \rangle)$ requires that the labels \texttt{Vehicle} and \texttt{Car} are both present, just having \texttt{Car} is not enough. Of course, it is possible to have two schema objects like $\otype_1 = (\{\texttt{Car}\}, \langle \texttt{make} : \texttt{string} \rangle)$ and $\otype_2 = (\{\texttt{Vehicle}, \texttt{Car}\}, \langle \texttt{make} : \texttt{string} \rangle)$. However, then it is not possible to specify that every \texttt{Employee} must have exactly one outgoing \texttt{OWNS} edge to a node conforming to either $\otype_1$ or $\otype_2$.

% TODO: In general, it's not possible to say that an object must conform to type 1 OR type 2 (union type). Problem with labels follows from that. But also union of two records is not possible.

\end{document}
